# 重构与模式

## 写作缘由

### 过度设计

- 指代码的灵活性和复杂性超出所需

### 设计不足

- 指所开发的软件设计不良

### 测试驱动开发和持续重构

- 编程对话

  - 问：编写一个测试，想系统提问

    - 红

  - 答：编写代码通过这个测试，回答这一提问

    - 绿

  - 提炼： 通过合并概念、消除歧义，提炼你的回答

    - 重构

  - 反复： 提出下一个问题，继续进行对话

- 优点

  - 保持较低的缺陷数量
  - 大胆地进行重构
  - 得到更加简单、更加优秀的代码
  - 编程时没有压力

### 重构与模式

- 模式是重构的目的地
- 重构是抵达这个目的地的道路

### 演进式设计

- 学习了解优秀软件设计的演变过程比学习优秀设计本身更有价值
- 测试驱动开发和持续重构是演进式设计的关键实践

## 重构

### 何谓重构

- 重构

  - 保持行为的转换
  - 重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低

- 重构过程

  - 去除重复、简化复杂逻辑和澄清模糊的代码

### 重构的动机

- 使新代码的增加更容易
- 改善既有代码的设计
- 对代码理解更透彻
- 提高编程的趣味性

### 众目睽睽

- 所有优秀的著述，都是不断修改而成的

  - 修改意味着重新审视

- 要得到最佳的重构结果，需要多人帮助

  - 极限编程采用结对编程和代码集体所有的原因之一

### 可读性好的代码

- 任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码

### 保持清晰

- 保持代码清晰类似于保持房间清洁
- 方法

  - 持续地去除重复
  - 简化
  - 澄清代码
  - 不能容忍代码脏乱

### 循序渐进

- 采取更小、更安全的步骤比采取更大的步骤更能快速达到目标

### 设计欠账

- 指无法做如下三件事

  - 去除重复
  - 简化代码
  - 澄清代码的意图

- 向上沟通

  - 使用欠账这样的金融隐喻来讨论技术问题

### 演变出新的架构

- 应用需求驱动框架
- 通过重构，持续改进应用程序和框架

### 复合重构

- 由多个低层次重构组成的高层次重构

  - 所完成的许多工作都涉及代码的搬移

- 测试是复合重构不可分割的一部分

### 测试驱动的重构

- 应用测试驱动开发得到替换代码，然后将老代码替换为新代码

  - 同事保留并重新运行老代码的测试

- 应用场景

  - 替换算法

### 复合重构的优点

- 描述了重构顺序的完整计划

  - 更安全
  - 更有效
  - 更高效

- 能够提示不明显的设计方向

  - 复合重构引导你从源头走到目的地

- 促进对实现模式的深入思考

  - 思考模式的各种实现方案是大有收益的

## 模式

### 何谓模式

- 三部分组成的规则

  - 某一坏境、一个问题以及解决问题的方案之间的关系

### 模式痴迷

- 指某人对模式过于痴迷，以至于无法不在代码中使用模式

### 实现模式的方式不止一种

### 通过重构实现、趋向和去除模式

- 目的是获得更好的设计，而不是实现模式

### 模式是否会使代码更加复杂

- 人们对模式的熟悉程度对于他们如何看待基于模式的重构将起决定性作用

### 模式知识

- 读优秀的模式图书来学习
- 建立学习小组

## 代码坏味

### 常见的设计问题

- 重复
- 不清晰
- 复杂

### 十二种坏味道

- 重复代码

  - 形成 Template Method
  - 用 Factory Method 引入多态创建
  - 链构造函数
  - 用 Composite 替换一/多之分
  - 提取 Composite 
  - 通过 Adapter 统一接口
  - 引入 Null  Object

- 方法过长

  - 组合方法
  - 将聚集操作搬移到 Collecting Parameter
  - 用 Command 替换条件调度程序
  - 将聚集操作搬移到 Visitor
  - 用 Strategy 替换条件逻辑

- 条件逻辑太复杂

  - 用 Strategy 替换条件逻辑
  - 将修饰功能搬移到 Decorator
  - 用 State 替换状态改变条件语句
  - 引入 Null Object

- 基本类型迷恋

  - 用类替换类型代码
  - 用 State 替换状态改变条件语句
  - 用 Strategy 替换条件逻辑
  - 用 Composite 替换隐含树
  - 用 Interpreter 替换隐式语言
  - 将装饰功能搬移到 Decorator
  - 用 Builder 封装 Composite

- 冗赘类

  - 内联 Singleton

- 类过大

  - 用 Command 替换条件调度程度
  - 用 State 替换状态改变条件语句
  - 用 Interpreter 替换隐式语言

- 分支语句

  - 用 Command 替换条件调度程度
  - 将聚集操作搬移到 Visitor

- 组合爆炸

  - 用 interpreter 替换隐式语言

- 怪异解决方案

  - 通过 Adapter 统一接口

## 创建

### 用 Creation Method 替换构造函数

- 动机

  - 解决一个类有多个构造函数带来的复杂性

- 实现

  - 类中的一个静态或者非静态的负责实例化类的新实例的方法

    - 表达出创建对象的意图

- 优点

  - 比构造函数能够更好地表达所创建的实例的种类
  - 避免了构造函数的局限，比如两个构造函数的参数数目和类型不能相同
  - 更容易发现无用的创建代码

- 缺点

  - 创建方式是非标准的：有些类用 new 实例化，而有些类用 Creation Method 实例化

- 步骤

  - 找出全包含构造函数
  - 找出处通过调用类的构造函数来创建实例的那个客户代码

    - 提炼方法重构生成一个公共、静态的方法

      - 应用搬移方法重构将 Creation Method 搬移到包含所选构造函数的类中

    - 这个方法就是 Creation Method

  - 将之前调用构造函数的地方改成调用 Creation Method
  - 重复以上步骤
  - 如果类中的某个构造函数在类外无调用的话，将它改为非公共的

- 变体

  - 参数化

    - 如果需要的 Creation Method 方法太多，可以考虑只实现常用的

  - 提取 Factory

    - 类中的创建太多方法会混淆类本身的意图，可以把创建相关的方法提取为 Factory 中



### 将创建知识搬移到 Factory

- Factory 定义

  - 实现一个或多个 Creation Method 的类就称为 Factory

- 动机

  - 当创建一个对象的知识散布在多个类中
  - 创建蔓延问题

    - 将创建的职责放在了不应该承担对象创建任务的类中

- 实现

  - 使用一个类封装创建逻辑和客户代码的实例化/配置选项
  - 客户代码可以告诉 Factory 实例如何实例化/配置一个对象
  - 然后用同一个 Factory 实例在运行时执行实例化/配置

- 优点

  - 合并创建逻辑和实例化/配置选项
  - 将客户代码与创建逻辑解耦

- 缺点

  - 如果可以直接实例化，会使设计复杂化

- 做法

  - 以下做法假设 Factory 将实现一个类，而不是类要实现的接口

  - 1. 实例化类就是一个与其他类合作实例化产品（即某个类的实例）的类

    - 需要用 Creation Method 来实例化产品

  - 2. 创建一个将成为工厂的新类，根据工厂所创建的产品给它命名

  - 3. 应用搬移方法重构将 Creation Method 搬移到工厂类中

    - 如果 Creation Method 是静态的，需要改为非静态的

  - 4. 将实例化类更新为实例化工厂对象，并调用工厂对象获取类的实例

  - 5. 在实例化中仍然使用其他类的数据和方法。

    - 将可用的任何东西搬移到工厂类中，这样它就能够尽可能多地处理创建工作

- 扩展

  - 如果创建逻辑过于复杂，就应该将其改为 Abstract Factory 模式

    - 支持太多创建选项
- 视频

[重构与模式 - Factory](https://www.bilibili.com/video/BV1X7411S7ho/)

### 用 Factory 封装类

- 实现

  - 把类的构造函数声明为非公共的，并通过 Factory 来创建它们的实例
  - 赋予这个 Factory 创建和返回实现了同一结构的类的实例的能力

- 动机

  - 客户代码不需要知道这些类的存在
  - 这些类都实现同一个接口，并且不太会发生改变

- 优点

  - 通过意图导向的 Creation Method 简化了不同种类实例的创建
  - 通过隐藏不需要公开的类减少了包结构的 “概念重量”
  - 帮助严格执行“面向接口编程，而不是面向实现”这一格言

- 缺点

  - 当需要创建新种类的实例时，必须新建/更新 Creation Method
  - 当客户只能获得 Factory 的二进制代码而无法获得源码时，对 Factory 的指定将受到限制

- 做法

  - 1. 找到调用类的构造函数来创建实例的一段客户代码。对构造函数调用应用提炼方法重构，生成一个公共、静态的方法。这个新方法就是一个 Creation Method。然后应用搬移方法将 Creation Method 搬移到包含所选构造函数的类的超类中
  - 2. 找出调用所选构造函数来创建相同实例的所有代码，将它们更新为调用 Creation Method
  - 3. 对可能使用类的构造函数创建的所有类型的实例重复步骤（1）和步骤（2）
  - 4. 把类的构造函数声明为非公共
  - 5. 对所有需要封装的类重构步骤（1）~步骤（4）
